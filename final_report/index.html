<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Arturo Flores, Ayah Abushama, Isolde Fang, Jakob Sorensen">

<title>Final Report: Lock Free Parallel Buddhabrot Rendering</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="final_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="final_report_files/libs/quarto-html/quarto.js"></script>
<script src="final_report_files/libs/quarto-html/popper.min.js"></script>
<script src="final_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="final_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="final_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="final_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="final_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="final_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="final_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Report: Lock Free Parallel Buddhabrot Rendering</h1>
<p class="subtitle lead">CS 184: Computer Graphics and Imaging, Spring 2023</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Arturo Flores, Ayah Abushama, Isolde Fang, Jakob Sorensen </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="video" class="level1">
<h1>Video</h1>
<iframe src="https://drive.google.com/file/d/1nrOErhFfT74fbMbEt_84sfd5yAf2pae6/preview" width="640" height="480" allow="autoplay"></iframe>
</section>
<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This project implements an OpenGL renderer that visualizes the Mandelbrot set through an alternate technique where we track the trajectory of values <em>not</em> in the Mandelbrot set (i.e., those that <em>do</em> converge to infinity) and render a probability distribution of the result. Such an image is called the Buddhabrot, originally invented by Melinda Greene. The renderer is self standing and does not depend on code from any of the course projects. The generation of the probability distribution was made multithreaded and lock free via use of compare-and-swap instructions (through the C++ standard library, if the hardware permits). We observed a 17x speed up over the single threaded code and could easily render 4K images with hundreds of millions of samples in minutes. Finally, the application supports interactive modification of the image, processed by the fragment shader and controlled by the keyboard.</p>
</section>
<section id="technical-approach" class="level1">
<h1>Technical approach</h1>
<p>Our project uses a variation of the the Mandelbrot set, which consists of the values <span class="math inline">\(c \in \mathbb{C}\)</span> for which the recursive function defined by <span class="math display">\[z_i =
z_{i - 1}^2 + c, z_0 = 0\]</span> <em>does not</em> diverge to infinity. In our case, we are only interested in those values that <em>do</em> diverge to infinity.</p>
<p>We’ll now describe the algorithm at a high level. We begin by initializing a two-dimensional array <span class="math inline">\(a\)</span> of integers to zeros, with each integer corresponding to a pixel in the final image. From here, we sample <span class="math inline">\(n\)</span> random complex numbers within a defined rectangle <span class="math inline">\(r\)</span> on the complex plane. For each, we check if it diverges within <span class="math inline">\(k\)</span> iterations (i.e., does it diverge by <span class="math inline">\(z_k\)</span>?). If it does not, we discard it. If it does, we track it’s trajectory, <span class="math inline">\(\{z_0, z_1, \dots, z_k\}\)</span> and for each <span class="math inline">\(z_i\)</span> check if it’s inside <span class="math inline">\(r\)</span>. If so, we get the corresponding pixel coordinates and increment the integer in the array <span class="math inline">\(a\)</span> at those coordinates by 1. We sample many <span class="math inline">\(c\)</span> values (on the order of one hundred million to one billion), each time following this process and updating <span class="math inline">\(a\)</span>. At the end, <span class="math inline">\(a\)</span> in effect serves as the <em>probability distribution</em> of the trajectories values take on their way to infinity. We lastly normalize these values to between 0 and 1, where the value for each pixel signifies its brightness. Though the mathematics seem simple, tremendous complexity and beauty emerge.</p>
<p>At this point, we have an image of a single color, with the shape visible only through variations in brightness. What if we’d like multiple colors? For this, we set a separate iteration limit <span class="math inline">\(k\)</span> for each of the color channels (<span class="math inline">\(k_r\)</span>, <span class="math inline">\(k_g\)</span>, <span class="math inline">\(k_b\)</span>). Then, instead of a single integer corresponding to a pixel in <span class="math inline">\(a\)</span>, we have three. We track the brightness levels for each independently, and also normalize them independently. Once normalized, we multiply the values by 255 to produce unsigned integers usable by OpenGL.</p>
<p>As aforementioned, we chose to start our project from scratch, implementing the OpenGL context and window management code ourselves, as opposed to using any starting code from the projects or other similar resources. Our primary resource for accomplishing this was the OpenGL documentation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and the great Learn OpenGL online tutorials<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Some tools and libraries we used in implementing the the project include C++20, CMake, GLM, and GLFW 3.3.</p>
<p>The general pipeline of the program is as follows: provide input parameters, sample complex numbers and evaluate the resulting trajectories, normalize the distribution, write the results to an OpenGL texture, and lastly render it onto a quad spanning the entire screen. The render can be further tuned by the user through uniforms fed to the shader and controlled by the keyboard. These include the intensity of the red, green, and blue values, as well as brightness generally.</p>
<p>In order to speed up the rendering of our image, we made the generation of the image multithreaded (while still being lock free). This is done during a phase with especially heavy computation, the sampling and evaluation phase. In the our moderl, each thread is responsible for a subset of the total number of samples. Each thread has access to its own random number generator, and running maximum values for each of channels (for the sake of normalization). However, they must all write to the same array <span class="math inline">\(a\)</span>. To avoid significant slow downs due to locks, we implemented the buffer with C++ atomic values, which, if the hardware provides the capability, allows multiple threads to read and write to the buffer without locking. In a rendering with 100 million samples and <span class="math inline">\(k_r = 200\)</span>, <span class="math inline">\(k_g = 100\)</span>, <span class="math inline">\(k_b = 150\)</span>, we saw a 17x rendering speedup, with it taking 920 seconds without multithreading and only 54 seconds with 20 threads.</p>
<p>Note that we had considered two alternate approaches – fragment shaders and compute shaders. We decided against the former because the operation is not done <em>per pixel</em>; the latter would possibly have provided significant speedups, but we decided against it as (1) we are unfamiliar with compute shaders, (2) their use requires newer versions of OpenGL, and (3) debugging would be made difficult.</p>
<p>The algorithm was first implemented based on the description found in the Wikipedia article<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. We found greater insights about the problem from an article by James Greene<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, the inventor of the method, and an article by Alex Boswell<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. At the debugging stage, we consulted a CalTech webpage<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> that gives high level instructions for a simpler Buddhabrot rendering project.</p>
<section id="problems-encountered" class="level2">
<h2 class="anchored" data-anchor-id="problems-encountered">Problems encountered</h2>
<p>We had a different project idea up until the milestone, the rendering of theoretical human traversable wormholes, but we were blocked for many days without results. We had seemed to implement all of the necessary steps but the resulting image was still not as expected. The wormhole was intended to conenct two “sections” of the universe (two images in our case), but inexplicably, only one was ever visible. The difficulty was due to the fact that the entirety of the project was based on advcaned theoretical physics, of which none of us were familiar. After being unable to make progress for many long days, we decided to switch to our current project: lock-free parallel Buddhabrot rendering. The process of deciding to abandon our old project and start a new one from scratch was tough but was worth it. Thankfully, we were able to utilize the code that handled window management and the OpenGL context.</p>
<p>We were able to get basic renderings in a reasonable amount of time, but they were at a crooked and cropped in an unusual way. This blocked us for a while, but after longer than we’d like to admit, we finally found the issue: an innocuous division with a complex number, which was intended to be done component wise (in contradiction of the definition of division for complex numbers). Our debugging process involved regular debugging (via GDB) and outputting values via print statements while interacting with the program.</p>
<p>There were also issues related to data races after multithreading was implemented. These were resolved by minimizing the dependencies threads have on each other, giving them each their own random number generator and local maximum brightness values. The latter were then accumulated once the threads had all completed. We made the only value shared among the threads the buffer of brightness values (<span class="math inline">\(a\)</span> in the description above). These errors showed up in subtle ways and were hard to spot. In the case of forgetting to synchronize access to the random number generator, there were only subtle light lines crossing regions of the screen.</p>
</section>
<section id="lessons-learned" class="level2">
<h2 class="anchored" data-anchor-id="lessons-learned">Lessons learned</h2>
<p>While it was definitely fulfilling building something from scratch, most of the group didn’t have a strong conceptual understanding of the mathematical concepts. There was an added difficulty of building the OpenGL application from scratch, which introduced both a new concept to learn to debug as well as added confusion. This, however, made the end result all the more rewarding — it was all code we produced and took time to thoroughly understand.</p>
<p>Parallelizing only one step of the rendering process allowed for a 17x speedup, but again, added the issue of race conditions. This added a random factor to the debugging process that varied from one computer to another. Implementing multithreading in a lock-free manner was optimal in terms of speed up, but proved to be difficult to debug. Realizing this would have been an issue from early on and accounting for it is a heavy lesson taken from this project.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p><img src="low_iter_1.png" class="img-fluid"></p>
<p><img src="low_iter_2.png" class="img-fluid"></p>
<p><img src="zoom_in_1.png" class="img-fluid"></p>
<p><img src="zoom_out_1.png" class="img-fluid"></p>
<p><img src="zoom_out_2.png" class="img-fluid"></p>
<p><img src="zoom_out_3.png" class="img-fluid"></p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p><a href="http://courses.cms.caltech.edu/cs11/material/advcpp/bbrot-1/index.html" class="uri">http://courses.cms.caltech.edu/cs11/material/advcpp/bbrot-1/index.html</a></p>
<p><a href="https://www.youtube.com/watch?v=FFftmWSzgmk&amp;pp=ygUKbWFuZGVsYnJvdA%3D%3D" class="uri">https://www.youtube.com/watch?v=FFftmWSzgmk&amp;pp=ygUKbWFuZGVsYnJvdA%3D%3D</a></p>
<p><a href="https://en.wikipedia.org/wiki/Buddhabrot" class="uri">https://en.wikipedia.org/wiki/Buddhabrot</a></p>
<p><a href="https://superliminal.com/fractals/bbrot/" class="uri">https://superliminal.com/fractals/bbrot/</a></p>
<p><a href="http://www.steckles.com/buddha/" class="uri">http://www.steckles.com/buddha/</a></p>
<p><a href="https://docs.gl/" class="uri">https://docs.gl/</a></p>
<p><a href="https://learnopengl.com/Getting-started/OpenGL" class="uri">https://learnopengl.com/Getting-started/OpenGL</a></p>
</section>
<section id="contributions-from-each-team-member" class="level1">
<h1>Contributions from each team member</h1>
<p>Jakob took the lead on the project, with a stronger conceptual understanding than the rest of the group. He led the implementation of the project code, including the OpenGL context, Buddhabrot related calculations, multithreading, and input management.</p>
<p>Isolde worked primarily on building the shader core, as well as with debugging the various issues that popped up, as well as the slides and website.</p>
<p>Arturo and Ayah both also aided in debugging the various issues that occurred as the core of the project code was being built up, as well as the slides and website.</p>
</section>
<section id="clip-for-showcase" class="level1">
<h1>Clip for Showcase</h1>
<iframe src="https://drive.google.com/file/d/1FX2--diUYGNsg-ow1VjY9-I9zrMXxgB-/preview" width="640" height="480" allow="autoplay"></iframe>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><a href="https://docs.gl/" class="uri">https://docs.gl/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://learnopengl.com/Getting-started/OpenGL" class="uri">https://learnopengl.com/Getting-started/OpenGL</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Buddhabrot" class="uri">https://en.wikipedia.org/wiki/Buddhabrot</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://superliminal.com/fractals/bbrot/" class="uri">https://superliminal.com/fractals/bbrot/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="http://www.steckles.com/buddha/" class="uri">http://www.steckles.com/buddha/</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a href="http://courses.cms.caltech.edu/cs11/material/advcpp/bbrot-1/index.html" class="uri">http://courses.cms.caltech.edu/cs11/material/advcpp/bbrot-1/index.html</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>